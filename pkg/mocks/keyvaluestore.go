package mocks

import (
	"github.com/allen13/con-job/pkg/distributed"
	"github.com/stretchr/testify/mock"
	"strings"
	"sync"
)

// KeyValueStore is an autogenerated mock type for the KeyValueStore type
type KeyValueStore struct {
	mock.Mock
	watches      map[string]distributed.KeyValueEventCallback
	watchesMutex sync.Mutex
}

// RunForLeader provides a mock function with given fields:
func (_m *KeyValueStore) RunForLeader() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Put provides a mock function with given fields: key, value
func (_m *KeyValueStore) Put(key string, value string) error {
	ret := _m.Called(key, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(key, value)
	} else {
		r0 = ret.Error(0)
	}

	_m.runKeyWatchCallbacks(key, value, distributed.PUT)

	return r0
}

// SoftPut provides a mock function with given fields: key, value
func (_m *KeyValueStore) SoftPut(key string, value string) error {
	ret := _m.Called(key, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(key, value)
	} else {
		r0 = ret.Error(0)
	}

	_m.runKeyWatchCallbacks(key, value, distributed.PUT)

	return r0
}

// Delete provides a mock function with given fields: value
func (_m *KeyValueStore) Delete(key string) error {
	ret := _m.Called(key)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Error(0)
	}

	_m.runKeyWatchCallbacks(key, "", distributed.DELETE)

	return r0
}

// Watch provides a mock function with given fields: keypath, keyValueEventCallback, watchWaitGroup
func (_m *KeyValueStore) Watch(keypath string, keyValueEventCallback distributed.KeyValueEventCallback, watchWaitGroup *sync.WaitGroup) {
	_m.watchesMutex.Lock()
	if _m.watches == nil {

		_m.watches = make(map[string]distributed.KeyValueEventCallback)
	}
	_m.watches[keypath] = keyValueEventCallback
	_m.watchesMutex.Unlock()

	watchWaitGroup.Done()
}

func (_m *KeyValueStore) runKeyWatchCallbacks(key string, value string, eventType distributed.KeyValueEventType) {
	for watch, watchCallback := range _m.watches {
		if strings.Contains(key, watch) {
			watchCallback(distributed.KeyValueEvent{
				Key:   key,
				Value: value,
				Type:  eventType,
			})
		}
	}
}
